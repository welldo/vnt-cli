
changelog-seen = 2

# =============================================================================
# 调整 LLVM 的编译方式
# =============================================================================
[llvm]

# 是否使用 Rust CI 构建 LLVM，而不是本地构建它。
#download-ci-llvm = if rust.channel == "dev" { "if-available" } else { false }

# LLVM 构建是发布还是调试构建
#optimize = true

# LLVM 是否应使用 ThinLTO 构建。
#thin-lto = false

# LLVM 版本构建是否应包含调试信息
#release-debuginfo = false

# 是否启用 LLVM 断言
#assertions = false

# 是否在构建中启用 LLVM 测试套件。
#tests = false

# LLVM插件是否启用
#plugins = true

# 指示构建LLVM时是否使用ccache。设置为“true”以使用第一个“ccache”
#ccache = false

# 如果为 true，则将 libstdc++ 静态链接到 rustc_llvm。
#static-libstdcpp = false

# 是否使用Ninja构建LLVM。这比 make 运行得快得多。
ninja = true

# LLVM 目标构建支持。
# 要添加对新目标的支持，请参阅 https://rustc-dev-guide.rust-lang.org/building/new-target.html.
#targets = "mipsel-unknown-linux-uclibc"

# 构建支持的 LLVM 实验目标。
#experimental-targets = "AVR;M68k;CSKY"

# 编译 LLVM 时限制并行链接器调用的数量。
#link-jobs = 0

# 是否将 LLVM 构建为动态链接库（而不是静态链接）。.
#link-shared = llvm.thin-lto

# 构建 llvm 时，这会配置附加到版本的内容。
#version-suffix = if rust.channel == "dev" { "-rust-dev" } else { "-rust-$version-$channel" }

# 在 MSVC 上，您可以使用 clang-cl 编译 LLVM，但测试套件未通过
#clang-cl = cc

# 将额外的编译器和链接器标志传递给 LLVM CMake 构建。
#cflags = ""
#cxxflags = ""
#ldflags = ""

# 构建 LLVM 时使用 libc++ 而不是 libstdc++。这是默认的.
#use-libcxx = false

# 此处指定的值将作为“-DLLVM_USE_LINKER”传递给 CMake。
#use-linker = <none> (path)

# 是否指定 `-DLLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN=YES`
#allow-old-toolchain = false

# 是否包含 Polly 优化器。
#polly = true

# 是否构建 clang 编译器。
#clang = true

# 是否启用llvm编译警告。
#enable-warnings = false

# 自定义 CMake 定义在构建 LLVM 时设置。
#build-config = {}

# =============================================================================
# 常规构建配置选项
# =============================================================================
[build]

# 用于“check”子命令的默认阶段
#check-stage = 0

# 用于“doc”子命令的默认阶段
#doc-stage = 0

# 用于“build”子命令的默认阶段
#build-stage = 1

# 用于“test”子命令的默认阶段
#test-stage = 1

# 用于“dist”子命令的默认阶段
#dist-stage = 2

# 用于“install”子命令的默认阶段
#install-stage = 2

# 用于“bench”子命令的默认阶段
#bench-stage = 2

# 为预编译快照编译器构建三元组。
#build = "x86_64-unknown-linux-gnu"

# 默认为“build”三元组。
#host = [build.build] (三元组列表)

# 默认为“主机”。
#target = mipsel-unknown-linux-uclibc
target = ["mipsel-unknown-linux-uclibc"]
#build.target = ["mipsel-unknown-linux-uclibc"]
# 使用此目录来存储构建工件。路径是相对于当前目录的
build-dir = "build"

# 不要下载指定的 Cargo src/stage0.json 版本，而是使用cargo
#cargo = "/path/to/cargo"

# 而不是下载 src/stage0.json 版本的编译器,如果指定，请使用此 rustc 二进制文件作为 stage0 快照编译器。如果你设置了这个，你可能还想设置“cargo”。
#rustc = "/path/to/rustc"

# 而不是下载指定的 rustfmt 的 src/stage0.json 版本，使用此 rustfmt 二进制文件作为 stage0 快照 rustfmt。
#rustfmt = "/path/to/rustfmt"

# 是否默认构建文档。
#docs = true

# 当通过显式传递路径禁用此功能时，您仍然可以构建文档
#docs-minification = true

# 用于指定 CSS、JavaScript 和 HTML 是否在以下情况下缩小的标志
#library-docs-private-items = false

# 用于指定私有项目是否应包含在库文档中的标志。
#compiler-docs = false

# 指示 git 子模块是否自动管理和更新。
#submodules = true

# 要使用的 GDB 可执行文件的路径（或名称）。
#gdb = "gdb"

# 要使用的 node.js 可执行文件。
#nodejs = "node"

# 要使用的 npm 可执行文件。
#npm = "npm"

# Python 解释器用于整个构建过程中的各种任务
#python = "python"

# 要使用的 REUSE 可执行文件的路径。
#reuse = "reuse"

# 强制 Cargo 检查 Cargo.lock 是否描述了精确的依赖关系
#locked-deps = false

# 供应商的源是否用于 Rust 依赖项。
#vendor = false

# 通常，构建系统会构建 Rust 编译器两次。
#full-bootstrap = false

# 启用扩展 Rust 工具集的构建，而不仅仅是编译器
extended = true

# 安装中包含的工具集。
 tools = [
     "cargo",
     "rls",
     "clippy",
     "rustdoc",
     "rustfmt",
     "rust-analyzer",
     "analysis",
     "src",
#    "rust-demangler",  # if profiler = true
 ]

# 详细级别：0 == 不详细，1 == 详细，2 == 非常详细，3 == 在每个 rustc 调用上打印环境变量
#verbose = 0

# 构建sanitizers运行时
#sanitizers = false

# 构建探查器运行时（使用依赖于的选项进行编译时需要在此运行时，例如“-C profile-generate”或“-C Instrument-coverage”）。
#profiler = false

# 指示链接到 Cargo 的本机库是否是静态的
#cargo-native-static = false

# 通过设置进程组的“nice”值，以低优先级运行构建
#low-priority = false

# 传递给 `./configure` 脚本的参数，在 distcheck 期间使用。
#configure-args = []

# 指示正在进行本地重建而不是完整引导
#local-rebuild = false

# 打印出每个 rustbuild 步骤花费了多长时间
#print-step-timings = false

# 按照 Unix 的定义，打印每个 rustbuild 步骤的资源使用数据结构用法。
#print-step-rusage = false

# 始终修补二进制文件以与 Nix 工具链一起使用。
#patch-binaries-for-nix = false

# 收集有关当前构建的信息和统计数据并将其写入磁盘。
#metrics = false

# =============================================================================
# 常规安装配置选项
# =============================================================================
[install]

# 在哪里安装生成的工具链。必须是绝对路径。
prefix = "/opt/mipsel-rust"

# 安装系统配置文件的位置。如果这是相对路径，它将安装在上面的“前缀”中
sysconfdir = "/etc"

# 上面`prefix`中的文档安装位置
docdir = "share/doc/rust"

# 在上面的“前缀”中安装二进制文件的位置
bindir = "bin"

# 在上面的`prefix`中安装库的位置
libdir = "lib"

# 在上面的`prefix`中安装手册页的位置
mandir = "share/man"

# 上面`prefix`中的数据安装在哪里
datadir = "share"

# =============================================================================
# 编译 Rust 代码本身的选项
# =============================================================================
[rust]

# 编译器和标准库编译时是否进行优化，以及使用什么级别的优化。警告：不支持使用 optimize = false 进行构建
# 有效的选项是：
#true - 启用优化。
#false - 禁用优化。
#0 - 禁用优化。
#1 - 基本优化。
#2 - 一些优化。
#3 - 所有优化。
#“s” - 优化二进制大小。
#“z” - 优化二进制大小，但也关闭循环矢量化。
optimize = true

# 指示应配置构建以调试 Rust。
#debug = false

# 是否从 CI 下载第一阶段和第二阶段编译器。
#download-rustc = false

# 每次编译器调用使用的代码生成单元数
#codegen-units = if incremental { 256 } else { 16 }

# 设置用于构建标准库的代码生成单元的数量
#codegen-units-std = codegen-units

# 是否为编译器和标准库启用调试断言。
#debug-assertions = rust.debug (boolean)

# 是否为标准库启用调试断言。
#debug-assertions-std = rust.debug-assertions (boolean)

# 是否离开debug！并追踪！调用 Rust 二进制文件。
#debug-logging = rust.debug-assertions (boolean)

# 编译器和标准是否启用溢出检查
#overflow-checks = rust.debug (boolean)

# 是否为标准库启用溢出检查。
#overflow-checks-std = rust.overflow-checks (boolean)

# 大多数 Rust 代码的 Debuginfo 级别对应于 `rustc` 的 `-C debuginfo=N` 选项。
# `0` - 无调试信息
# `1` - 仅行表 - 足以生成包含行的回溯信息和内联函数，在源代码处设置断点位置，并在调试器中单步执行
# `2` - 包含变量和类型信息的完整调试信息
# 可以针对 Rust 代码的特定子集（rustc、std 或工具）进行覆盖。
#debuginfo-level = if rust.debug { 1 } else { 0 }

# 编译器的调试信息级别。
#debuginfo-level-rustc = rust.debuginfo-level

# 标准库的调试信息级别。
#debuginfo-level-std = rust.debuginfo-level

# 工具的调试信息级别。
#debuginfo-level-tools = rust.debuginfo-level

# 使用compiletest运行的测试套件的调试信息级别。
#debuginfo-level-tests = 0

# rustc 应该使用分割 debuginfo 来构建吗？默认值取决于平台。有效值与“-C split-debuginfo”接受的值相同(`off`/`unpacked`/`packed`).
#split-debuginfo = if linux { off } else if windows { packed } else if apple { unpacked }

# `panic!` 是否生成回溯 (RUST_BACKTRACE)
#backtrace = true

# 构建 rustc 时是否始终使用增量编译
#incremental = false

# 构建多线程 rustc
#parallel-compiler = false

# 将被硬编码到生成的默认链接器用于未显式指定默认链接器的目标的编译器请注意，这不是链接器用于链接所述编译器。
#default-linker = <none> (path)

# Rust 构建生成的“通道”。
#channel = "dev"

# 要附加到“rustc --version”输出的描述性字符串，即也用于 debuginfo `DW_AT_ Producer` 等地方。
#description = ""

# musl 安装目录的根位置。图书馆目录还需要包含 libunwind.a 以进行展开实现
#musl-root = <platform specific> (path)

# 默认情况下，“rustc”可执行文件是在 Unix 上使用“-Wl,-rpath”标志构建的平台
#rpath = true

# 在执行时打印每个测试名称，以帮助调试测试工具本身中的问题。
#verbose-tests = false

# 测试是否通过优化进行编译的标志（-O 标志）。
#optimize-tests = true

# 是否运行 codegen 测试的标志。
#codegen-tests = true

# 是否自动从 .git 检索 git 信息的标志。
#omit-git-hash = if rust.channel == "dev" { true } else { false }

# 运行“x dist”时是否默认创建源 tarball。
#dist-src = true

# 构建或测试可选组件
#save-toolstates = <none> (path)

# 这是将为 rustc 编译的 codegen 后端数组正在编译。
#codegen-backends = ["llvm"]

# 是否将编译 LLD 并使其在 sysroot 中可用
lld = true

# LLD 是否将用于在引导期间链接 Rust 包支持的平台
#use-lld = false

# 某些 LLVM 工具（例如 llvm-objdump）是否将在系统根目录。
#llvm-tools = false

# 是否拒绝板条箱中的警告
#deny-warnings = true

# 在引导期间打印内部编译器错误的回溯
#backtrace-on-ice = false

# 是否验证生成的LLVM IR
#verify-llvm-ir = false

# 使用非默认 ThinLTO 导入限制来编译编译器
#thin-lto-import-instr-limit = if incremental { 10 } else { LLVM default (currently 100) }

# 将 debuginfo 路径映射到 `/rust/$sha/...`。
#remap-debuginfo = false

# 将编译器和 LLVM 链接到“jemalloc”而不是默认的 libc 分配器。
#jemalloc = false

# 除了以下之外，还使用“nll 比较模式”在各种测试套件中运行测试在正常模式下运行测试。
#test-compare-mode = false

# 所有目标的 llvm-libunwind 的全局默认值。
#llvm-libunwind = 'no'

# 在标准库中启用 Windows Control Flow Guard 检查。
#control-flow-guard = false

# 启用符号修改版本 v0。
#new-symbol-mangling = true|false (see comment)

# 选择将用于编译 rustc 的 LTO 模式 “thin”或“fat”
#lto = "thin-local"

# 构建启用优化和 -Zvalidate-mir 的编译器，目前仅适用于“std”
#validate-mir-opts = 3

# =============================================================================
# 针对特定目标的选项
#
# 以下每个选项的范围仅限于中的特定目标三元组
# 问题并用于确定如何编译每个目标.
# =============================================================================
#[target.x86_64-unknown-linux-gnu]
[target.mips-unknown-linux-uclibc]
# C编译器用于编译C代码。
cc = "/opt/buildroot/bin/mipsel-linux-gcc"

# C++ 编译器用于编译 C++ 代码
cxx = "/opt/buildroot/bin/mipsel-linux-g++"

# Archiver 用于组装从 C/C++ 代码编译的静态库。应使用绝对路径，否则 LLVM 构建将中断。
ar = "/opt/buildroot/bin/mipsel-linux-ar"

# Ranlib 用于组装从 C/C++ 代码编译的静态库。应使用绝对路径，否则 LLVM 构建将中断。
ranlib = "/opt/buildroot/bin/mipsel-linux-ranlib"

# 用于引导 Rust 代码的链接器
linker = "/opt/buildroot/bin/mipsel-linux-gcc"

# 要链接的自定义 LLVM 安装的“llvm-config”二进制文件的路径
#llvm-config = <none> (path)

# 覆盖对这是否是 Rust 补丁 LLVM 的检测。这将被使用与 llvm-config 或 build.submodules = false 结合使用。
#llvm-has-rust-patches = if llvm-config { false } else { true }

# 通常构建系统可以找到 LLVM 的 FileCheck 实用程序
#llvm-filecheck = "/path/to/llvm-version/bin/FileCheck"

# 使用 LLVM libunwind 作为 Rust 展开器的实现。接受的值为“in-tree”（以前为 true）、“system”或“no”（以前为 false）
#llvm-libunwind = 'no' if Linux, 'in-tree' if Fuchsia

# 如果此目标适用于 Android，则需要此选项来指定位置
#android-ndk = <none> (path)

# 为此目标构建sanitizers运行时。
#sanitizers = build.sanitizers (bool)

# 如果为 true，则为此目标构建探查器运行时（编译时需要）具有依赖于该运行时的选项，例如“-C profile-generate”或`-C 仪器覆盖范围`)。这也可能被赋予现有构建的路径来自 LLVM 编译器-rt 的分析运行时库。
#profiler = build.profiler (bool)

# 该选项支持在每个目标中独立启用“rpath”
#rpath = rust.rpath (bool)

# 强制此目标的标准库的静态或动态链接。
#crt-static = <platform-specific> (bool)

# musl 安装目录的根位置。
#musl-root = build.musl-root (path)

# musl libdir 的完整路径。
#musl-libdir = musl-root/lib

# “wasm32-wasi” sysroot 的根位置。
#wasi-root = <none> (path)

# 用于测试配置 QEMU 映像所在的位
#qemu-rootfs = <none> (path)

# 跳过为此目标构建“std”库。默认启用,包含“-none”、“nvptx”、“switch”或“-uefi”的目标三元组。
#no-std = <platform-specific> (bool)

# =============================================================================
# 分销选项
#
# 这些选项与分发相关，主要针对 Rust 项目本身。
# 您可能不需要关心这些选项中的任何一个
# =============================================================================
[dist]

# 这是构建系统将签名的工件的文件夹。
#sign-folder = <none> (path)

# 所有工件最终将上传到的远程地址。
#upload-addr = <none> (URL)

# 是否构建纯源 tarball 来上传
#src-tarball = true

# 构建工具时是否允许失败
#missing-tools = false

# 生成 dist tarball 时使用的压缩格式列表
#compression-formats = ["gz", "xz"]

# 压缩 tarball 需要花费多少时间。越好
#压缩配置文件，压缩所需的时间越长。
#
#可用选项：快速fast、平衡balanced、最佳best
#compression-profile = "fast"

# 将 MinGW 中的链接器、DLL 和各种库复制到 rustc 工具链中。
#include-mingw-linker = true
